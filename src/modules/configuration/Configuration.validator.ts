/* tslint:disable */
// generated by typescript-json-validator
import { inspect } from 'util';
import Ajv = require('ajv');
import Configuration from './Configuration';
export const ajv = new Ajv({
  allErrors: true,
  coerceTypes: false,
  format: 'fast',
  nullable: true,
  unicode: true,
  uniqueItems: true,
  useDefaults: true
});

ajv.addMetaSchema(require('ajv/lib/refs/json-schema-draft-06.json'));

export { Configuration };
export const ConfigurationSchema = {
  $schema: 'http://json-schema.org/draft-07/schema#',
  defaultProperties: [],
  definitions: {
    CandleInterval: {
      enum: ['DAY_1', 'HOUR_1', 'MINUTE_1', 'MINUTE_5'],
      type: 'string'
    },
    EMAShortLong: {
      defaultProperties: [],
      properties: {
        l: {
          type: 'number'
        },
        s: {
          type: 'number'
        }
      },
      required: ['l', 's'],
      type: 'object'
    },
    EMAShortLongOverride: {
      defaultProperties: [],
      properties: {
        coins: {
          items: {
            type: 'string'
          },
          type: 'array'
        },
        l: {
          type: 'number'
        },
        s: {
          type: 'number'
        }
      },
      required: ['coins', 'l', 's'],
      type: 'object'
    },
    MainMarket: {
      enum: ['BTC', 'ETH', 'EUR', 'USD', 'USDT'],
      type: 'string'
    }
  },
  properties: {
    HODL: {
      description: 'Coins to hodl',
      items: {
        type: 'string'
      },
      type: 'array'
    },
    amountPerInvest: {
      description: 'Amount for every invest',
      type: 'number'
    },
    blacklist: {
      description: 'Coins to sell as soon as possible and never buy',
      items: {
        type: 'string'
      },
      type: 'array'
    },
    debug: {
      description: 'If true, all buy and sell api requests get skipped',
      type: 'boolean'
    },
    emaConfiguration: {
      defaultProperties: [],
      description: 'Defines ema short and long',
      properties: {
        default: {
          $ref: '#/definitions/EMAShortLong'
        },
        override: {
          items: {
            $ref: '#/definitions/EMAShortLongOverride'
          },
          type: 'array'
        }
      },
      required: ['default'],
      type: 'object'
    },
    enableReporting: {
      description:
        'If true, the bot will call the report function at every end of round',
      type: 'boolean'
    },
    exactPositiveTicks: {
      description: 'Will invest when positive ticks are exactly this number',
      type: 'number'
    },
    ignoreTokenizedStocks: {
      description:
        'If true, it will not try to buy tokenized stocks. E.g. prohibited in your country',
      type: 'boolean'
    },
    mainMarket: {
      $ref: '#/definitions/MainMarket',
      description:
        'Market to trade all coins on. E.g. BTC or USDT\nOnly tested USDT so far'
    },
    minNegativeTicks: {
      description:
        'Will reject when negative ticks are equal or below this number',
      type: 'number'
    },
    refreshTimeout: {
      description: 'Amount in milliseconds to wait before next round',
      type: 'number'
    },
    tickInterval: {
      $ref: '#/definitions/CandleInterval',
      description: 'Defines the interval used for candles'
    }
  },
  required: [
    'HODL',
    'amountPerInvest',
    'blacklist',
    'debug',
    'emaConfiguration',
    'enableReporting',
    'exactPositiveTicks',
    'ignoreTokenizedStocks',
    'mainMarket',
    'minNegativeTicks',
    'refreshTimeout',
    'tickInterval'
  ],
  type: 'object'
};
export type ValidateFunction<T> = ((data: unknown) => data is T) &
  Pick<Ajv.ValidateFunction, 'errors'>;
export const isConfiguration = ajv.compile(
  ConfigurationSchema
) as ValidateFunction<Configuration>;
export default function validate(value: unknown): Configuration {
  if (isConfiguration(value)) {
    return value;
  } else {
    throw new Error(
      ajv.errorsText(
        isConfiguration.errors!.filter((e: any) => e.keyword !== 'if'),
        { dataVar: 'Configuration' }
      ) +
        '\n\n' +
        inspect(value)
    );
  }
}
